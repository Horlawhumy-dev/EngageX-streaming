<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Practice Session Report</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; margin: 20px;}
        #videoPreview { width: 100%; max-width: 600px; display: block; margin-bottom: 20px; border: 1px solid #ccc;}
        button { padding: 10px 15px; margin-right: 10px; cursor: pointer;}
        #reportContainer { margin-top:30px; border:1px solid #ccc; padding:20px; border-radius:8px; background:#f9f9f9; display:none;}
        #reportContainer h3, #reportContainer h4 { color:#333; border-bottom:1px solid #eee; padding-bottom:5px; margin-bottom:15px;}
        .score-grid { display:grid; grid-template-columns: repeat(auto-fit,minmax(200px,1fr)); gap:15px; margin-bottom:20px;}
        .score-item { background:#fff; padding:15px; border-radius:5px; border:1px solid #ddd;}
        .score-item strong { display: block; margin-bottom:5px; color:#555;}
        .summary-section { margin-bottom:20px;}
        .summary-section p { white-space: pre-wrap;}
        .compiled-video { margin-top:20px; font-size:1.1em;}
        #realtimeFeedbackArea {font-size:1.1em; color:teal; margin-top:12px;}
        #emotionArea {font-size:1em; color:#666; margin-top:10px;}
    </style>
</head>
<body>
<h2>Practice Session</h2>
<video id="videoPreview" autoplay muted></video>
<div>
    <label for="roomSelect">Choose Room:</label>
    <select id="roomSelect">
        <option value="conference_room">Conference Room</option>
        <option value="board_room_1">Board Room 1</option>
        <option value="board_room_2">Board Room 2</option>
    </select>
    <label for="aiQuestionToggle">Enable AI Audience Questions:</label>
    <input type="checkbox" id="aiQuestionToggle" checked>
    <button id="startBtn">Start Recording</button>
    <button id="stopBtn" disabled>Stop Recording</button>

    <div style="margin-top: 15px;">
        <label for="audienceQuestionField"><b>Send Audience Question:</b></label>
        <input type="text" id="audienceQuestionField" placeholder="Type question here..." style="width:300px;">
        <button id="audienceQuestionSendBtn" type="button">Send Question</button>
    </div>
    <div id="realtimeFeedbackArea"></div>
    <div id="emotionArea"></div>
</div>
<p id="status">Status: Waiting...</p>

<div id="reportContainer">
    <h3>Session Report</h3>
    <div id="sessionInfo">
        <h4>Session Details:</h4>
        <p><strong>Session ID:</strong> <span id="reportSessionId"></span></p>
        <p><strong>Session Name:</strong> <span id="reportSessionName"></span></p>
        <p><strong>Duration:</strong> <span id="reportDuration"></span></p>
        <p><strong>Virtual Environment:</strong> <span id="reportRoom"></span></p>
    </div>
    <div id="aggregatedScores">
        <h4>Aggregated Scores:</h4>
        <div class="score-grid" id="aggregatedScoresGrid"></div>
    </div>
    <div id="derivedScores">
        <h4>Derived Scores:</h4>
        <div class="score-grid" id="derivedScoresGrid"></div>
    </div>
    <div id="fullSummary">
        <h4>Summary Feedback:</h4>
        <div class="summary-section">
            <strong>Strength:</strong>
            <p id="summaryStrength"></p>
        </div>
        <div class="summary-section">
            <strong>Area of Improvement:</strong>
            <p id="summaryImprovement"></p>
        </div>
        <div class="summary-section">
            <strong>General Feedback:</strong>
            <p id="summaryGeneral"></p>
        </div>
        <div class="summary-section">
            <strong>Gestures Percentage:</strong>
            <p id="summaryGestures"></p>
        </div>
    </div>
    <div class="compiled-video" id="compiledVideoUrlText"></div>
</div>

<script>
// const API_BASE_URL = "https://api.engagexai.io";
// const API_BASE_URL = "https://api-stream.engagexai.io"; // For local testing
const API_BASE_URL = "http://localhost:8001"; // For local testing
const API_TOKEN = "cbb104b86b94b2116b6b542e496454dea3940039";
let sessionId;
let stream = null;
let chunkTimer = null, currentRecorder = null;
let isRecording = false;
let socket;
let startTime;

let selectedRoom = document.getElementById('roomSelect').value;
let aiQuestionsEnabled = document.getElementById('aiQuestionToggle').checked;

document.getElementById('roomSelect').addEventListener('change', e => selectedRoom = e.target.value);
document.getElementById('aiQuestionToggle').addEventListener('change', e => aiQuestionsEnabled = e.target.checked);

async function createPracticeSession() {
    try {
        const response = await fetch(`${API_BASE_URL}/sessions/sessions/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Token ${API_TOKEN}`
            },
            body: JSON.stringify({
                session_name: "Live Practice Session",
                session_type: "public",
                virtual_environment: selectedRoom,
                goals: ["I want to be more captivating"]
            })
        });
        if (!response.ok) {
            console.error('Failed to create practice session:', response.status);
            let errorText = await response.text();
            console.error('Error details:', errorText);
            document.getElementById("status").textContent = `Status: Error creating session (${response.status}).`;
            return null;
        }
        const data = await response.json();
        sessionId = data.id;
        console.log('Created Practice Session with ID:', sessionId, 'in Room:', data.virtual_environment);
        return sessionId;
    } catch (error) {
        console.error('Error creating practice session:', error);
        document.getElementById("status").textContent = "Status: Error creating session.";
        return null;
    }
}

function arrayBufferToBase64(buffer) {
    let binary = '', bytes = new Uint8Array(buffer);
    for (let b of bytes) binary += String.fromCharCode(b);
    return window.btoa(binary);
}

function startNewRecorder() {
    let mimeType = '';
    if (MediaRecorder.isTypeSupported('video/webm; codecs=vp9,opus')) mimeType = 'video/webm; codecs=vp9,opus';
    else if (MediaRecorder.isTypeSupported('video/webm; codecs=vp8,opus')) mimeType = 'video/webm; codecs=vp8,opus';
    else if (MediaRecorder.isTypeSupported('video/webm')) mimeType = 'video/webm';

    if (!mimeType) {
        console.error("No supported video/webm mime type found.");
        document.getElementById("status").textContent = "Status: Browser does not support video recording.";
        stopRecordingAndCleanup();
        return;
    }

    currentRecorder = new MediaRecorder(stream, {mimeType});
    let recordedChunks = [];
    currentRecorder.ondataavailable = (event) => {
        if (event.data && event.data.size > 0) recordedChunks.push(event.data);
    };
    currentRecorder.onstop = () => {
        if (recordedChunks.length > 0 && socket && socket.readyState === WebSocket.OPEN && isRecording) {
            new Blob(recordedChunks, {type: mimeType}).arrayBuffer().then(buffer => {
                const base64Data = arrayBufferToBase64(buffer);
                socket.send(JSON.stringify({
                    type: "media",
                    data: base64Data,
                    session_id: sessionId
                }));
                console.log(`Sent finalized media chunk (size: ${buffer.byteLength} bytes) to server.`);
            });
        }
        recordedChunks = [];
        if (isRecording) {
            console.log("Starting next recorder...");
            startNewRecorder();
        }
        else {
            console.log("Recording fully stopped.");
            triggerSessionReport();
        }
    };
    currentRecorder.onerror = (event) => {
        console.error("MediaRecorder error:", event.error);
        document.getElementById("status").textContent = `Status: Recording error: ${event.error.name}`;
        stopRecordingAndCleanup();
    };
    try {
        currentRecorder.start();
        console.log("Recorder started.");
        chunkTimer = setTimeout(() => {
            console.log("Chunk duration reached, stopping recorder.");
            if (currentRecorder && currentRecorder.state === "recording") currentRecorder.stop();
        }, 7000);
    } catch(err) {
        console.error("Error starting recorder:", err);
        document.getElementById("status").textContent = "Status: Failed to start recording.";
        stopRecordingAndCleanup();
    }
}

document.getElementById("startBtn").addEventListener("click", async () => {
    document.getElementById("reportContainer").style.display = "none";
    document.getElementById("status").textContent = "Status: Creating session...";
    const sessionIdResult = await createPracticeSession();
    if (!sessionIdResult) { document.getElementById("status").textContent = "Status: Failed to start session."; return; }
    document.getElementById("status").textContent = "Status: Requesting camera/mic...";
    try {
        stream = await navigator.mediaDevices.getUserMedia({video: true, audio: true});
        document.getElementById("videoPreview").srcObject = stream;
        startTime = new Date();
        let wsProtocol = API_BASE_URL.startsWith("https") ? "wss" : "ws";
        let wsUrl = `${wsProtocol}://${API_BASE_URL.split('://')[1]}/ws/socket_server/?session_id=${sessionId}&room_name=${selectedRoom}&ai_questions_enabled=${aiQuestionsEnabled}`;
        console.log("Connecting to WebSocket:", wsUrl);
        socket = new WebSocket(wsUrl);
        socket.binaryType = "arraybuffer";
        socket.onopen = () => {
            console.log("WebSocket Connected with Session ID:", sessionId, "Room:", selectedRoom, "AI Questions Enabled:", aiQuestionsEnabled);
            document.getElementById("status").textContent = "Status: Recording...";
            document.getElementById("startBtn").disabled = true;
            document.getElementById("stopBtn").disabled = false;
            isRecording = true;
            startNewRecorder();
        };
        socket.onmessage = (e) => {
            try {
                const data = JSON.parse(e.data);
                // Handle different message types from the server
                if (data.type === "realtime_feedback") {
                    console.log("Real-time Feedback:", data.feedback);
                    document.getElementById("realtimeFeedbackArea").textContent = data.feedback || '';
                }
                else if (data.type === "full_analysis_update") {
                    console.log("Chunk Full Analysis Update:", data.analysis);
                }
                else if (data.type === "window_emotion_update") {
                    console.log("Window Emotion Update:", data.emotion, data.emotion_s3_url);
                    document.getElementById("emotionArea").textContent = data.emotion ? "Emotion: " + data.emotion : "";
                }
                else if (data.type === "audience_question") {
                    console.log("Received AI Audience Question:", data.question);
                    alert("AI Audience Question: " + data.question);
                }
                else {
                    console.log("Server message:", e.data);
                }
            } catch (error) { console.error("Error parsing or handling WebSocket message:", error);}
        };
        socket.onerror = (error) => {
            console.error("WebSocket Error:", error);
            document.getElementById("status").textContent = "Status: WebSocket error.";
            stopRecordingAndCleanup();
        };
        socket.onclose = (event) => {
            console.log("WebSocket Disconnected", event.code, event.reason);
            if (!event.wasClean) {
                document.getElementById("status").textContent = "Status: WebSocket connection lost.";
                stopRecordingAndCleanup(false);
            }
        };
    } catch (error) {
        console.error("Camera/Mic Access Error:", error);
        document.getElementById("status").textContent = "Status: Camera/mic access denied or error.";
        stopRecordingAndCleanup(false);
    }
});

function stopRecordingAndCleanup(triggerReport = true) {
    console.log("Stopping recording and cleaning up.");
    isRecording = false;
    if (chunkTimer) { clearTimeout(chunkTimer); chunkTimer = null; }
    if (currentRecorder && currentRecorder.state !== "inactive") {
        console.log("Stopping MediaRecorder."); currentRecorder.stop();
    }
    else if (!currentRecorder && triggerReport) {
        if (sessionId) { triggerSessionReport(); }
        else { document.getElementById("status").textContent = "Status: Session not started."; }
    }
    if (socket && socket.readyState === WebSocket.OPEN) { console.log("Closing WebSocket."); socket.close(1000, "Recording finished"); }
    if (stream) { console.log("Stopping media tracks."); stream.getTracks().forEach(track => track.stop()); stream = null; }
    document.getElementById("startBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
}

document.getElementById("stopBtn").addEventListener("click", () => {
    stopRecordingAndCleanup(true);
});

document.getElementById('audienceQuestionSendBtn').addEventListener('click', function () {
    let qf = document.getElementById('audienceQuestionField');
    let question = qf.value.trim();
    if (!question) return alert("Please type a question before sending.");
    if (!socket || socket.readyState !== WebSocket.OPEN) return alert("WebSocket is not connected. Start recording first.");
    socket.send(JSON.stringify({ type: "audience_question", question, session_id: sessionId }));
    qf.value = "";
    alert("Question sent!");
});

// ---- Rendering and polling logic: only GET displays (never POST) ----
async function triggerSessionReport() {
    if (!sessionId) {
        document.getElementById("status").textContent = "Status: Cannot generate report. Session not created.";
        return;
    }
    document.getElementById("status").textContent = "Status: Generating report...";
    const endTime = new Date();
    const durationInSeconds = startTime ? Math.round((endTime - startTime) / 1000) : 0;
    try {
        await fetch(`${API_BASE_URL}/sessions/sessions-report/${sessionId}/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Token ${API_TOKEN}`
            },
            body: JSON.stringify({duration: durationInSeconds})
        });
        console.log("Triggered report POST for session", sessionId);
    } catch (e) { console.error("Error POSTing for report trigger:", e); }
    document.getElementById("reportContainer").style.display = "block";
    startReportPolling(sessionId);
}

function startReportPolling(sessionId) {
    let attempts = 0, maxAttempts = 24, pollingInterval = 5000;
    function poll() {
        attempts++;
        fetch(`${API_BASE_URL}/sessions/sessions-report/${sessionId}/`, {
            headers: {'Authorization': `Token ${API_TOKEN}`}
        })
        .then(async resp => {
            if (!resp.ok) {
                console.warn(`Polling failed (${resp.status})`);
                document.getElementById("compiledVideoUrlText").innerHTML = `Compiled Video URL: Error (${resp.status})`;
                return;
            }
            const reportData = await resp.json();
            console.log('ðŸ“„ Fetched Session Report via GET:', reportData);
            renderReportFromGET(reportData);
            if (reportData.compiled_video_url) {
                document.getElementById("compiledVideoUrlText").innerHTML =
                    `<strong>Compiled Video URL:</strong> <a href="${reportData.compiled_video_url}" target="_blank">${reportData.compiled_video_url}</a>`;
                document.getElementById("status").textContent = "Status: Report finalized.";
            } else if (attempts < maxAttempts) {
                document.getElementById("compiledVideoUrlText").innerHTML =
                  `<strong>Compiled Video URL:</strong> <span>Still processing...</span>`;
                document.getElementById("status").textContent =
                  "Status: Report generating (waiting for compiled video)...";
                setTimeout(poll, pollingInterval);
            } else {
                document.getElementById("compiledVideoUrlText").innerHTML =
                  `<strong>Compiled Video URL:</strong> Timed out.`;
                document.getElementById("status").textContent =
                  "Status: Compiled video unavailable (timed out).";
            }
        })
        .catch(err => {
            console.error("Polling error:", err);
            document.getElementById("compiledVideoUrlText").innerHTML =
                `<strong>Compiled Video URL:</strong> Error loading report data.`;
            document.getElementById("status").textContent =
                "Status: Error fetching report result.";
        });
    }
    poll();
}

function renderReportFromGET(reportData) {
    document.getElementById("reportSessionId").textContent = reportData.session_id || "N/A";
    document.getElementById("reportSessionName").textContent = reportData.session_name || "N/A";
    document.getElementById("reportDuration").textContent = reportData.duration || 'N/A';
    document.getElementById("reportRoom").textContent = reportData.virtual_environment || 'N/A';

    // Aggregated Scores
    const aggregatedKeys = {
        volume: 'Volume', pitch_variability: 'Pitch Variability', pace: 'Pace', pauses: 'Pauses',
        conviction: 'Conviction', clarity: 'Clarity', impact: 'Impact', brevity: 'Brevity',
        trigger_response: 'Trigger Response', filler_words: 'Filler Words', grammar: 'Grammar',
        posture: 'Posture', motion: 'Motion'
    };
    let agg = reportData.aggregated_scores || {}, grid = document.getElementById("aggregatedScoresGrid");
    grid.innerHTML = '';
    for (let k in aggregatedKeys) {
        if (agg[k] !== undefined) {
            let el = document.createElement('div'); el.className = "score-item";
            el.innerHTML = `<strong>${aggregatedKeys[k]}:</strong> ${agg[k]}`;
            grid.appendChild(el);
        }
    }

    // Derived Scores
    const derivedKeys = {
        audience_engagement: 'Audience Engagement',
        overall_captured_impact: 'Overall Captured Impact',
        vocal_variety: 'Vocal Variety',
        emotional_impact: 'Emotional Impact',
        body_language: 'Body Language',
        transformative_communication: 'Transformative Communication',
        structure_and_clarity: 'Structure and Clarity',
        language_and_word_choice: 'Language and Word Choice'
    };
    let derived = reportData.derived_scores || {}, derivedGrid = document.getElementById("derivedScoresGrid");
    derivedGrid.innerHTML = '';
    for (let k in derivedKeys) {
        if (derived[k] !== undefined) {
            let el = document.createElement('div'); el.className = "score-item";
            el.innerHTML = `<strong>${derivedKeys[k]}:</strong> ${derived[k]}`;
            derivedGrid.appendChild(el);
        }
    }

    // Summary
    let summary = reportData.full_summary || {};
    document.getElementById("summaryStrength").innerHTML =
        (summary["Strength"] || []).map(item => `â€¢ ${item}`).join("<br>");
    document.getElementById("summaryImprovement").innerHTML =
        (summary["Area of Improvement"] || []).map(item => `â€¢ ${item}`).join("<br>");
    document.getElementById("summaryGeneral").textContent =
        summary["General Feedback Summary"] || "N/A";
    document.getElementById("summaryGestures").textContent =
        ((reportData.gestures_percentage !== undefined && reportData.gestures_percentage !== null)
             ? `${reportData.gestures_percentage}%` : "N/A");
}

// Initial UI state
document.getElementById("stopBtn").disabled = true;
document.getElementById("reportContainer").style.display = "none";
document.getElementById("realtimeFeedbackArea").textContent = "";
document.getElementById("emotionArea").textContent = "";

</script>
</body>
</html>